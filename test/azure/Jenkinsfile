import static java.util.UUID.randomUUID

// REQUIRED BUILD PARAMETERS:
// - clusterName (optional)
// - kubernetesVerison (optional) (default to value of: https://storage.googleapis.com/kubernetes-release/release/latest.txt)
// - tenantId
// - subscriptionId
// - destroyCluster
// TODO(colemickens): paramterize the subscription, tenant id, etc

// TODO(general): this could be broken out so that the config step could be parameterized...
//                so each provider can use whatever withEnv/Creds they want and populate '.config.json'

latestReleaseUrl = "https://storage.googleapis.com/kubernetes-release/release/latest.txt"

node {
	deleteDir()
	checkout scm

	sh 'git rev-parse --short HEAD > commit'
	env.GIT_COMMIT = readFile('commit').trim()

	if (kubernetesVersion == "") {
		kubernetesVersion = sh(script: "curl ${latestReleaseUrl}", returnStdout: true)
	}
	if (clusterName == "") {
		clusterName = "k8s-any-${env.BUILD_NUMBER}-${env.GIT_COMMIT}"
	}
	if (azureMachinePassword == "") {
		azureMachinePassword = randomUUID()
	}
	def kanyTag = "${dockerRepo}/k8s-anywhere:${env.GIT_COMMIT}-${env.BUILD_NUMBER}"
	def ignitionTag = "${dockerRepo}/k8s-ignition:${env.GIT_COMMIT}-${env.BUILD_NUMBER}"
	env.IGNITION_TAG = ignitionTag

	stage 'build hyperkube'
	// shallow clone master
	// export KUBE_DOCKER_REGISTRY=docker.io
	// export KUBE_DOCKER_OWNER=colemickens
	// export KUBE_DOCKER_VERSION=${BUILD_NUMBER}.${GIT_COMMMIT}
	// ./dev-push-hyperkube.sh

	stage 'build phase2'
	dir('phase2/ignition') {
		def ignitionImg = docker.build(ignitionTag, '--pull .')
		ignitionImg.push()
	}


	stage 'build kubernetes-anywhere'
	def kanyImg = docker.build(kanyTag, '--pull .')
	kanyImg.push()


	kanyImg.inside() {
		withCredentials([[
			$class: 'UsernamePasswordMultiBinding',
			credentialsId: 'azure_service_principal',
			usernameVariable: 'AZURE_CLIENT_ID',
			passwordVariable: 'AZURE_CLIENT_SECRET']]) {

			stage "deploy cluster"
			def config = getConfig()
			writeFile(file: '.config.json', text: config)
			writeFile(file: 'config.json', text: config)
			archiveArtifacts artifacts: 'config.json', fingerprint: true

			sh("""set -x; \
			cat <<-EOF | make deploy\n
					${clusterName}
					azure\n\n\n\n\n\n\n
					westus2\n
					${azureMachinePassword}
					${tenantId}
					${subscriptionId}
					${env.AZURE_CLIENT_ID}
					${env.AZURE_CLIENT_SECRET}
					${ignitionTag}
					gcr.io/google_containers
					${kubernetesVersion}\n\n\n\n\n
			EOF""")

			sh("cp ./phase1/azure/.tmp/kubeconfig.json ./kubeconfig.json")
			archiveArtifacts artifacts: 'kubeconfig.json', fingerprint: true


			stage 'wait on cluster'
			sh("make validate")


			stage 'deploy addons'
			sh("make addons")


			if (testCluster=="y") {
				stage 'test cluster'
				withEnv(['KUBECONFIG=' + cwd() + '/phase1/azure/.tmp/kubeconfig.json']) {
					make conformtest
				}
			}

			if (destroyCluster=="y") {
				stage 'destroy cluster'
				input 'destroy cluster?'
				withEnv(["FORCE_DESTROY=y"]) {
					sh("cd ./phase1/azure && ./do destroy")
				}
			}
		}
	}
}

	def cwd() {
		sh 'pwd > pwd.current'
		return readFile('pwd.current').trim()
	}

	def getConfig() {
				def configTest = """
					{
						"phase1": {
							"cluster_name": "${clusterName}",
							"azure": {
								"admin_password": "${azureMachinePassword}",
								"tenant_id": "${tenantId}",
								"subscription_id": "${subscriptionId}",
							"client_id": "${env.AZURE_CLIENT_ID}",
							"client_secret": "${env.AZURE_CLIENT_SECRET}"
						}
					},
					"phase2": {
						"installer_container": "${env.IGNITION_TAG}"
					}
				}
			""".trim()

			writeFile(file: 'testconfig.json', text: configTest)

			def configTemplatePath = 'test/azure/config.json.template'
			def configTemplate = readFile('test/azure/config.json.template')
			return sh (
				script: "jq -s '.[0] * .[1]' ${configTemplatePath} testconfig.json",
				returnStdout: true
			).trim()
	}
